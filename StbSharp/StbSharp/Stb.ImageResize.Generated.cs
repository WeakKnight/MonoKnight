// Generated by Sichem at 01.04.2017 10:16:07

using System;
using System.Runtime.InteropServices;
using Sichem;

namespace StbSharp
{
	unsafe partial class Stb
	{
		[StructLayout(LayoutKind.Sequential)]
		public struct stbir__contributors
		{
			public int n0;
			public int n1;
		}

		public const int STBIR_EDGE_CLAMP = 1;
		public const int STBIR_EDGE_REFLECT = 2;
		public const int STBIR_EDGE_WRAP = 3;
		public const int STBIR_EDGE_ZERO = 4;
		public const int STBIR_FILTER_DEFAULT = 0;
		public const int STBIR_FILTER_BOX = 1;
		public const int STBIR_FILTER_TRIANGLE = 2;
		public const int STBIR_FILTER_CUBICBSPLINE = 3;
		public const int STBIR_FILTER_CATMULLROM = 4;
		public const int STBIR_FILTER_MITCHELL = 5;
		public const int STBIR_COLORSPACE_LINEAR = 0;
		public const int STBIR_COLORSPACE_SRGB = 1;
		public const int STBIR_MAX_COLORSPACES = 2;
		public const int STBIR_TYPE_UINT8 = 0;
		public const int STBIR_TYPE_UINT16 = 1;
		public const int STBIR_TYPE_UINT32 = 2;
		public const int STBIR_TYPE_FLOAT = 3;
		public const int STBIR_MAX_TYPES = 4;
		public static byte[] stbir__type_size = {1, 2, 4, 4};

		public static float[] stbir__srgb_uchar_to_linear_float =
		{
			0.000000f, 0.000304f, 0.000607f, 0.000911f, 0.001214f,
			0.001518f, 0.001821f, 0.002125f, 0.002428f, 0.002732f, 0.003035f, 0.003347f, 0.003677f, 0.004025f, 0.004391f,
			0.004777f, 0.005182f, 0.005605f, 0.006049f, 0.006512f, 0.006995f, 0.007499f, 0.008023f, 0.008568f, 0.009134f,
			0.009721f, 0.010330f, 0.010960f, 0.011612f, 0.012286f, 0.012983f, 0.013702f, 0.014444f, 0.015209f, 0.015996f,
			0.016807f, 0.017642f, 0.018500f, 0.019382f, 0.020289f, 0.021219f, 0.022174f, 0.023153f, 0.024158f, 0.025187f,
			0.026241f, 0.027321f, 0.028426f, 0.029557f, 0.030713f, 0.031896f, 0.033105f, 0.034340f, 0.035601f, 0.036889f,
			0.038204f, 0.039546f, 0.040915f, 0.042311f, 0.043735f, 0.045186f, 0.046665f, 0.048172f, 0.049707f, 0.051269f,
			0.052861f, 0.054480f, 0.056128f, 0.057805f, 0.059511f, 0.061246f, 0.063010f, 0.064803f, 0.066626f, 0.068478f,
			0.070360f, 0.072272f, 0.074214f, 0.076185f, 0.078187f, 0.080220f, 0.082283f, 0.084376f, 0.086500f, 0.088656f,
			0.090842f, 0.093059f, 0.095307f, 0.097587f, 0.099899f, 0.102242f, 0.104616f, 0.107023f, 0.109462f, 0.111932f,
			0.114435f, 0.116971f, 0.119538f, 0.122139f, 0.124772f, 0.127438f, 0.130136f, 0.132868f, 0.135633f, 0.138432f,
			0.141263f, 0.144128f, 0.147027f, 0.149960f, 0.152926f, 0.155926f, 0.158961f, 0.162029f, 0.165132f, 0.168269f,
			0.171441f, 0.174647f, 0.177888f, 0.181164f, 0.184475f, 0.187821f, 0.191202f, 0.194618f, 0.198069f, 0.201556f,
			0.205079f, 0.208637f, 0.212231f, 0.215861f, 0.219526f, 0.223228f, 0.226966f, 0.230740f, 0.234551f, 0.238398f,
			0.242281f, 0.246201f, 0.250158f, 0.254152f, 0.258183f, 0.262251f, 0.266356f, 0.270498f, 0.274677f, 0.278894f,
			0.283149f, 0.287441f, 0.291771f, 0.296138f, 0.300544f, 0.304987f, 0.309469f, 0.313989f, 0.318547f, 0.323143f,
			0.327778f, 0.332452f, 0.337164f, 0.341914f, 0.346704f, 0.351533f, 0.356400f, 0.361307f, 0.366253f, 0.371238f,
			0.376262f, 0.381326f, 0.386430f, 0.391573f, 0.396755f, 0.401978f, 0.407240f, 0.412543f, 0.417885f, 0.423268f,
			0.428691f, 0.434154f, 0.439657f, 0.445201f, 0.450786f, 0.456411f, 0.462077f, 0.467784f, 0.473532f, 0.479320f,
			0.485150f, 0.491021f, 0.496933f, 0.502887f, 0.508881f, 0.514918f, 0.520996f, 0.527115f, 0.533276f, 0.539480f,
			0.545725f, 0.552011f, 0.558340f, 0.564712f, 0.571125f, 0.577581f, 0.584078f, 0.590619f, 0.597202f, 0.603827f,
			0.610496f, 0.617207f, 0.623960f, 0.630757f, 0.637597f, 0.644480f, 0.651406f, 0.658375f, 0.665387f, 0.672443f,
			0.679543f, 0.686685f, 0.693872f, 0.701102f, 0.708376f, 0.715694f, 0.723055f, 0.730461f, 0.737911f, 0.745404f,
			0.752942f, 0.760525f, 0.768151f, 0.775822f, 0.783538f, 0.791298f, 0.799103f, 0.806952f, 0.814847f, 0.822786f,
			0.830770f, 0.838799f, 0.846873f, 0.854993f, 0.863157f, 0.871367f, 0.879622f, 0.887923f, 0.896269f, 0.904661f,
			0.913099f, 0.921582f, 0.930111f, 0.938686f, 0.947307f, 0.955974f, 0.964686f, 0.973445f, 0.982251f, 0.991102f, 1.0f
		};

		public static uint[] fp32_to_srgb8_tab4 =
		{
			0x0073000d, 0x007a000d, 0x0080000d, 0x0087000d, 0x008d000d, 0x0094000d,
			0x009a000d, 0x00a1000d, 0x00a7001a, 0x00b4001a, 0x00c1001a, 0x00ce001a, 0x00da001a, 0x00e7001a, 0x00f4001a,
			0x0101001a, 0x010e0033, 0x01280033, 0x01410033, 0x015b0033, 0x01750033, 0x018f0033, 0x01a80033, 0x01c20033,
			0x01dc0067, 0x020f0067, 0x02430067, 0x02760067, 0x02aa0067, 0x02dd0067, 0x03110067, 0x03440067, 0x037800ce,
			0x03df00ce, 0x044600ce, 0x04ad00ce, 0x051400ce, 0x057b00c5, 0x05dd00bc, 0x063b00b5, 0x06970158, 0x07420142,
			0x07e30130, 0x087b0120, 0x090b0112, 0x09940106, 0x0a1700fc, 0x0a9500f2, 0x0b0f01cb, 0x0bf401ae, 0x0ccb0195,
			0x0d950180, 0x0e56016e, 0x0f0d015e, 0x0fbc0150, 0x10630143, 0x11070264, 0x1238023e, 0x1357021d, 0x14660201,
			0x156601e9, 0x165a01d3, 0x174401c0, 0x182401af, 0x18fe0331, 0x1a9602fe, 0x1c1502d2, 0x1d7e02ad, 0x1ed4028d,
			0x201a0270, 0x21520256, 0x227d0240, 0x239f0443, 0x25c003fe, 0x27bf03c4, 0x29a10392, 0x2b6a0367, 0x2d1d0341,
			0x2ebe031f, 0x304d0300, 0x31d105b0, 0x34a80555, 0x37520507, 0x39d504c5, 0x3c37048b, 0x3e7c0458, 0x40a8042a,
			0x42bd0401, 0x44c20798, 0x488e071e, 0x4c1c06b6, 0x4f76065d, 0x52a50610, 0x55ac05cc, 0x5892058f, 0x5b590559,
			0x5e0c0a23, 0x631c0980, 0x67db08f6, 0x6c55087f, 0x70940818, 0x74a007bd, 0x787d076c, 0x7c330723
		};

		public static int stbir__min(int a, int b)
		{
			return (int) ((a) < (b) ? a : b);
		}

		public static int stbir__max(int a, int b)
		{
			return (int) ((a) > (b) ? a : b);
		}

		public static float stbir__saturate(float x)
		{
			if ((x) < (0)) return (float) (0);
			if ((x) > (1)) return (float) (1);
			return (float) (x);
		}

		public static float stbir__srgb_to_linear(float f)
		{
			if (f <= 0.04045f) return (float) (f/12.92f);
			else return (float) (pow((double) ((f + 0.055f)/1.055f), (double) (2.4f)));
		}

		public static float stbir__linear_to_srgb(float f)
		{
			if (f <= 0.0031308f) return (float) (f*12.92f);
			else return (float) (1.055f*(float) (pow((double) (f), (double) (1/2.4f))) - 0.055f);
		}

		public static float stbir__filter_trapezoid(float x, float scale)
		{
			float halfscale = (float) (scale/2);
			float t = (float) (0.5f + halfscale);
			x = ((float) (fabs((double) (x))));
			if ((x) >= (t)) return (float) (0);
			else
			{
				float r = (float) (0.5f - halfscale);
				if (x <= r) return (float) (1);
				else return (float) ((t - x)/scale);
			}

		}

		public static float stbir__support_trapezoid(float scale)
		{
			return (float) (0.5f + scale/2);
		}

		public static float stbir__filter_triangle(float x, float s)
		{
			x = ((float) (fabs((double) (x))));
			if (x <= 1.0f) return (float) (1 - x);
			else return (float) (0);
		}

		public static float stbir__filter_cubic(float x, float s)
		{
			x = ((float) (fabs((double) (x))));
			if ((x) < (1.0f)) return (float) ((4 + x*x*(3*x - 6))/6);
			else if ((x) < (2.0f)) return (float) ((8 + x*(-12 + x*(6 - x)))/6);
			return (float) (0.0f);
		}

		public static float stbir__filter_catmullrom(float x, float s)
		{
			x = ((float) (fabs((double) (x))));
			if ((x) < (1.0f)) return (float) (1 - x*x*(2.5f - 1.5f*x));
			else if ((x) < (2.0f)) return (float) (2 - x*(4 + x*(0.5f*x - 2.5f)));
			return (float) (0.0f);
		}

		public static float stbir__filter_mitchell(float x, float s)
		{
			x = ((float) (fabs((double) (x))));
			if ((x) < (1.0f)) return (float) ((16 + x*x*(21*x - 36))/18);
			else if ((x) < (2.0f)) return (float) ((32 + x*(-60 + x*(36 - 7*x)))/18);
			return (float) (0.0f);
		}

		public static float stbir__support_zero(float s)
		{
			return (float) (0);
		}

		public static float stbir__support_one(float s)
		{
			return (float) (1);
		}

		public static float stbir__support_two(float s)
		{
			return (float) (2);
		}

		public static int stbir__use_upsampling(float ratio)
		{
			return (int) ((ratio) > (1) ? 1 : 0);
		}

		public static int stbir__use_width_upsampling(stbir__info stbir_info)
		{
			return (int) (stbir__use_upsampling((float) (stbir_info.horizontal_scale)));
		}

		public static int stbir__use_height_upsampling(stbir__info stbir_info)
		{
			return (int) (stbir__use_upsampling((float) (stbir_info.vertical_scale)));
		}

		public static int stbir__get_filter_pixel_width(int filter, float scale)
		{
			if ((stbir__use_upsampling((float) (scale))) != 0)
				return (int) (ceil((double) (stbir__filter_info_table[filter].support((float) (1/scale))*2)));
			else return (int) (ceil((double) (stbir__filter_info_table[filter].support((float) (scale))*2/scale)));
		}

		public static int stbir__get_filter_pixel_margin(int filter, float scale)
		{
			return (int) (stbir__get_filter_pixel_width((int) (filter), (float) (scale))/2);
		}

		public static int stbir__get_coefficient_width(int filter, float scale)
		{
			if ((stbir__use_upsampling((float) (scale))) != 0)
				return (int) (ceil((double) (stbir__filter_info_table[filter].support((float) (1/scale))*2)));
			else return (int) (ceil((double) (stbir__filter_info_table[filter].support((float) (scale))*2)));
		}

		public static int stbir__get_contributors(float scale, int filter, int input_size, int output_size)
		{
			if ((stbir__use_upsampling((float) (scale))) != 0) return (int) (output_size);
			else return (int) (input_size + stbir__get_filter_pixel_margin((int) (filter), (float) (scale))*2);
		}

		public static int stbir__get_total_horizontal_coefficients(stbir__info info)
		{
			return
				(int)
					(info.horizontal_num_contributors*
					 stbir__get_coefficient_width((int) (info.horizontal_filter), (float) (info.horizontal_scale)));
		}

		public static int stbir__get_total_vertical_coefficients(stbir__info info)
		{
			return
				(int)
					(info.vertical_num_contributors*
					 stbir__get_coefficient_width((int) (info.vertical_filter), (float) (info.vertical_scale)));
		}

		public static stbir__contributors* stbir__get_contributor(stbir__contributors* contributors, int n)
		{
			return &contributors[n];
		}

		public static float* stbir__get_coefficient(float* coefficients, int filter, float scale, int n, int c)
		{
			int width = (int) (stbir__get_coefficient_width((int) (filter), (float) (scale)));
			return &coefficients[width*n + c];
		}

		public static int stbir__edge_wrap_slow(int edge, int n, int max)
		{
			switch (edge)
			{
				case STBIR_EDGE_ZERO:
					return (int) (0);
				case STBIR_EDGE_CLAMP:
					if ((n) < (0)) return (int) (0);
					if ((n) >= (max)) return (int) (max - 1);
					return (int) (n);
				case STBIR_EDGE_REFLECT:
				{
					if ((n) < (0))
					{
						if ((n) < (max)) return (int) (-n);
						else return (int) (max - 1);
					}
					if ((n) >= (max))
					{
						int max2 = (int) (max*2);
						if ((n) >= (max2)) return (int) (0);
						else return (int) (max2 - n - 1);
					}
					return (int) (n);
				}
				case STBIR_EDGE_WRAP:
					if ((n) >= (0)) return (int) (n%max);
					else
					{
						int m = (int) ((-n)%max);
						if (m != 0) m = (int) (max - m);
						return (int) (m);
					}
					return (int) (n);
				default:
					;
					return (int) (0);
			}

		}

		public static int stbir__edge_wrap(int edge, int n, int max)
		{
			if (((n) >= (0)) && ((n) < (max))) return (int) (n);
			return (int) (stbir__edge_wrap_slow((int) (edge), (int) (n), (int) (max)));
		}

		public static void stbir__calculate_sample_range_upsample(int n, float out_filter_radius, float scale_ratio,
			float out_shift, int* in_first_pixel, int* in_last_pixel, float* in_center_of_out)
		{
			float out_pixel_center = (float) ((float) (n) + 0.5f);
			float out_pixel_influence_lowerbound = (float) (out_pixel_center - out_filter_radius);
			float out_pixel_influence_upperbound = (float) (out_pixel_center + out_filter_radius);
			float in_pixel_influence_lowerbound = (float) ((out_pixel_influence_lowerbound + out_shift)/scale_ratio);
			float in_pixel_influence_upperbound = (float) ((out_pixel_influence_upperbound + out_shift)/scale_ratio);
			*in_center_of_out = (float) ((out_pixel_center + out_shift)/scale_ratio);
			*in_first_pixel = ((int) (floor((double) (in_pixel_influence_lowerbound + 0.5))));
			*in_last_pixel = ((int) (floor((double) (in_pixel_influence_upperbound - 0.5))));
		}

		public static void stbir__calculate_sample_range_downsample(int n, float in_pixels_radius, float scale_ratio,
			float out_shift, int* out_first_pixel, int* out_last_pixel, float* out_center_of_in)
		{
			float in_pixel_center = (float) ((float) (n) + 0.5f);
			float in_pixel_influence_lowerbound = (float) (in_pixel_center - in_pixels_radius);
			float in_pixel_influence_upperbound = (float) (in_pixel_center + in_pixels_radius);
			float out_pixel_influence_lowerbound = (float) (in_pixel_influence_lowerbound*scale_ratio - out_shift);
			float out_pixel_influence_upperbound = (float) (in_pixel_influence_upperbound*scale_ratio - out_shift);
			*out_center_of_in = (float) (in_pixel_center*scale_ratio - out_shift);
			*out_first_pixel = ((int) (floor((double) (out_pixel_influence_lowerbound + 0.5))));
			*out_last_pixel = ((int) (floor((double) (out_pixel_influence_upperbound - 0.5))));
		}

		public static void stbir__calculate_coefficients_upsample(stbir__info stbir_info, int filter, float scale,
			int in_first_pixel, int in_last_pixel, float in_center_of_out, stbir__contributors* contributor,
			float* coefficient_group)
		{
			int i;
			float total_filter = (float) (0);
			float filter_scale;
			contributor->n0 = (int) (in_first_pixel);
			contributor->n1 = (int) (in_last_pixel);
			for (i = (int) (0); i <= in_last_pixel - in_first_pixel; i++)
			{
				float in_pixel_center = (float) ((float) (i + in_first_pixel) + 0.5f);
				coefficient_group[i] =
					(float) (stbir__filter_info_table[filter].kernel((float) (in_center_of_out - in_pixel_center), (float) (1/scale)));
				if (((i) == (0)) && (coefficient_group[i] == 0))
				{
					contributor->n0 = (int) (++in_first_pixel);
					i--;
				}
				total_filter += (float) (coefficient_group[i]);
			}
			filter_scale = (float) (1/total_filter);
			for (i = (int) (0); i <= in_last_pixel - in_first_pixel; i++)
			{
				coefficient_group[i] *= (float) (filter_scale);
			}
			for (i = (int) (in_last_pixel - in_first_pixel); (i) >= (0); i--)
			{
				if ((coefficient_group[i]) != 0) break;
				contributor->n1 = (int) (contributor->n0 + i - 1);
			}
		}

		public static void stbir__calculate_coefficients_downsample(stbir__info stbir_info, int filter, float scale_ratio,
			int out_first_pixel, int out_last_pixel, float out_center_of_in, stbir__contributors* contributor,
			float* coefficient_group)
		{
			int i;
			contributor->n0 = (int) (out_first_pixel);
			contributor->n1 = (int) (out_last_pixel);
			for (i = (int) (0); i <= out_last_pixel - out_first_pixel; i++)
			{
				float out_pixel_center = (float) ((float) (i + out_first_pixel) + 0.5f);
				float x = (float) (out_pixel_center - out_center_of_in);
				coefficient_group[i] =
					(float) (stbir__filter_info_table[filter].kernel((float) (x), (float) (scale_ratio))*scale_ratio);
			}
			for (i = (int) (out_last_pixel - out_first_pixel); (i) >= (0); i--)
			{
				if ((coefficient_group[i]) != 0) break;
				contributor->n1 = (int) (contributor->n0 + i - 1);
			}
		}

		public static void stbir__normalize_downsample_coefficients(stbir__info stbir_info, stbir__contributors* contributors,
			float* coefficients, int filter, float scale_ratio, float shift, int input_size, int output_size)
		{
			int num_contributors =
				(int) (stbir__get_contributors((float) (scale_ratio), (int) (filter), (int) (input_size), (int) (output_size)));
			int num_coefficients = (int) (stbir__get_coefficient_width((int) (filter), (float) (scale_ratio)));
			int i;
			int j;
			int skip;
			for (i = (int) (0); (i) < (output_size); i++)
			{
				float scale;
				float total = (float) (0);
				for (j = (int) (0); (j) < (num_contributors); j++)
				{
					if (((i) >= (contributors[j].n0)) && (i <= contributors[j].n1))
					{
						float coefficient =
							(float)
								(*
									stbir__get_coefficient(coefficients, (int) (filter), (float) (scale_ratio), (int) (j),
										(int) (i - contributors[j].n0)));
						total += (float) (coefficient);
					}
					else if ((i) < (contributors[j].n0)) break;
				}
				scale = (float) (1/total);
				for (j = (int) (0); (j) < (num_contributors); j++)
				{
					if (((i) >= (contributors[j].n0)) && (i <= contributors[j].n1))
						*
							stbir__get_coefficient(coefficients, (int) (filter), (float) (scale_ratio), (int) (j),
								(int) (i - contributors[j].n0)) *= (float) (scale);
					else if ((i) < (contributors[j].n0)) break;
				}
			}
			for (j = (int) (0); (j) < (num_contributors); j++)
			{
				int range;
				int max;
				int width;
				skip = (int) (0);
				while ((*stbir__get_coefficient(coefficients, (int) (filter), (float) (scale_ratio), (int) (j), (int) (skip))) ==
				       (0))
				{
					skip++;
				}
				contributors[j].n0 += (int) (skip);
				while ((contributors[j].n0) < (0))
				{
					contributors[j].n0++;
					skip++;
				}
				range = (int) (contributors[j].n1 - contributors[j].n0 + 1);
				max = (int) (stbir__min((int) (num_coefficients), (int) (range)));
				width = (int) (stbir__get_coefficient_width((int) (filter), (float) (scale_ratio)));
				for (i = (int) (0); (i) < (max); i++)
				{
					if ((i + skip) >= (width)) break;
					*stbir__get_coefficient(coefficients, (int) (filter), (float) (scale_ratio), (int) (j), (int) (i)) =
						(float)
							(*stbir__get_coefficient(coefficients, (int) (filter), (float) (scale_ratio), (int) (j), (int) (i + skip)));
				}
			}
			for (i = (int) (0); (i) < (num_contributors); i++)
			{
				contributors[i].n1 = (int) (stbir__min((int) (contributors[i].n1), (int) (output_size - 1)));
			}
		}

		public static void stbir__calculate_filters(stbir__info stbir_info, stbir__contributors* contributors,
			float* coefficients, int filter, float scale_ratio, float shift, int input_size, int output_size)
		{
			int n;
			int total_contributors =
				(int) (stbir__get_contributors((float) (scale_ratio), (int) (filter), (int) (input_size), (int) (output_size)));
			if ((stbir__use_upsampling((float) (scale_ratio))) != 0)
			{
				float out_pixels_radius = (float) (stbir__filter_info_table[filter].support((float) (1/scale_ratio))*scale_ratio);
				for (n = (int) (0); (n) < (total_contributors); n++)
				{
					float in_center_of_out;
					int in_first_pixel;
					int in_last_pixel;
					stbir__calculate_sample_range_upsample((int) (n), (float) (out_pixels_radius), (float) (scale_ratio),
						(float) (shift), &in_first_pixel, &in_last_pixel, &in_center_of_out);
					stbir__calculate_coefficients_upsample(stbir_info, (int) (filter), (float) (scale_ratio), (int) (in_first_pixel),
						(int) (in_last_pixel), (float) (in_center_of_out), stbir__get_contributor(contributors, (int) (n)),
						stbir__get_coefficient(coefficients, (int) (filter), (float) (scale_ratio), (int) (n), (int) (0)));
				}
			}
			else
			{
				float in_pixels_radius = (float) (stbir__filter_info_table[filter].support((float) (scale_ratio))/scale_ratio);
				for (n = (int) (0); (n) < (total_contributors); n++)
				{
					float out_center_of_in;
					int out_first_pixel;
					int out_last_pixel;
					int n_adjusted = (int) (n - stbir__get_filter_pixel_margin((int) (filter), (float) (scale_ratio)));
					stbir__calculate_sample_range_downsample((int) (n_adjusted), (float) (in_pixels_radius), (float) (scale_ratio),
						(float) (shift), &out_first_pixel, &out_last_pixel, &out_center_of_in);
					stbir__calculate_coefficients_downsample(stbir_info, (int) (filter), (float) (scale_ratio), (int) (out_first_pixel),
						(int) (out_last_pixel), (float) (out_center_of_in), stbir__get_contributor(contributors, (int) (n)),
						stbir__get_coefficient(coefficients, (int) (filter), (float) (scale_ratio), (int) (n), (int) (0)));
				}
				stbir__normalize_downsample_coefficients(stbir_info, contributors, coefficients, (int) (filter),
					(float) (scale_ratio), (float) (shift), (int) (input_size), (int) (output_size));
			}

		}

		public static float* stbir__get_decode_buffer(stbir__info stbir_info)
		{
			return &stbir_info.decode_buffer[stbir_info.horizontal_filter_pixel_margin*stbir_info.channels];
		}

		public static void stbir__decode_scanline(stbir__info stbir_info, int n)
		{
			int c;
			int channels = (int) (stbir_info.channels);
			int alpha_channel = (int) (stbir_info.alpha_channel);
			int type = (int) (stbir_info.type);
			int colorspace = (int) (stbir_info.colorspace);
			int input_w = (int) (stbir_info.input_w);
			ulong input_stride_bytes = (ulong) (stbir_info.input_stride_bytes);
			float* decode_buffer = stbir__get_decode_buffer(stbir_info);
			int edge_horizontal = (int) (stbir_info.edge_horizontal);
			int edge_vertical = (int) (stbir_info.edge_vertical);
			ulong in_buffer_row_offset =
				(ulong) (stbir__edge_wrap((int) (edge_vertical), (int) (n), (int) (stbir_info.input_h))*(int) input_stride_bytes);
			void* input_data = (sbyte*) (stbir_info.input_data) + in_buffer_row_offset;
			int max_x = (int) (input_w + stbir_info.horizontal_filter_pixel_margin);
			int decode = (int) ((type)*(STBIR_MAX_COLORSPACES) + (colorspace));
			int x = (int) (-stbir_info.horizontal_filter_pixel_margin);
			if (((edge_vertical) == (STBIR_EDGE_ZERO)) && (((n) < (0)) || ((n) >= (stbir_info.input_h))))
			{
				for (; (x) < (max_x); x++)
				{
					for (c = (int) (0); (c) < (channels); c++)
					{
						decode_buffer[x*channels + c] = (float) (0);
					}
				}
				return;
			}

			switch (decode)
			{
				case ((STBIR_TYPE_UINT8)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (; (x) < (max_x); x++)
					{
						int decode_pixel_index = (int) (x*channels);
						int input_pixel_index = (int) (stbir__edge_wrap((int) (edge_horizontal), (int) (x), (int) (input_w))*channels);
						for (c = (int) (0); (c) < (channels); c++)
						{
							decode_buffer[decode_pixel_index + c] = (float) (((float) (((byte*) (input_data))[input_pixel_index + c]))/255);
						}
					}
					break;
				case ((STBIR_TYPE_UINT8)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (; (x) < (max_x); x++)
					{
						int decode_pixel_index = (int) (x*channels);
						int input_pixel_index = (int) (stbir__edge_wrap((int) (edge_horizontal), (int) (x), (int) (input_w))*channels);
						for (c = (int) (0); (c) < (channels); c++)
						{
							decode_buffer[decode_pixel_index + c] =
								(float) (stbir__srgb_uchar_to_linear_float[((byte*) (input_data))[input_pixel_index + c]]);
						}
						if ((stbir_info.flags & (1 << 1)) == 0)
							decode_buffer[decode_pixel_index + alpha_channel] =
								(float) (((float) (((byte*) (input_data))[input_pixel_index + alpha_channel]))/255);
					}
					break;
				case ((STBIR_TYPE_UINT16)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (; (x) < (max_x); x++)
					{
						int decode_pixel_index = (int) (x*channels);
						int input_pixel_index = (int) (stbir__edge_wrap((int) (edge_horizontal), (int) (x), (int) (input_w))*channels);
						for (c = (int) (0); (c) < (channels); c++)
						{
							decode_buffer[decode_pixel_index + c] =
								(float) (((float) (((ushort*) (input_data))[input_pixel_index + c]))/65535);
						}
					}
					break;
				case ((STBIR_TYPE_UINT16)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (; (x) < (max_x); x++)
					{
						int decode_pixel_index = (int) (x*channels);
						int input_pixel_index = (int) (stbir__edge_wrap((int) (edge_horizontal), (int) (x), (int) (input_w))*channels);
						for (c = (int) (0); (c) < (channels); c++)
						{
							decode_buffer[decode_pixel_index + c] =
								(float) (stbir__srgb_to_linear((float) (((float) (((ushort*) (input_data))[input_pixel_index + c]))/65535)));
						}
						if ((stbir_info.flags & (1 << 1)) == 0)
							decode_buffer[decode_pixel_index + alpha_channel] =
								(float) (((float) (((ushort*) (input_data))[input_pixel_index + alpha_channel]))/65535);
					}
					break;
				case ((STBIR_TYPE_UINT32)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (; (x) < (max_x); x++)
					{
						int decode_pixel_index = (int) (x*channels);
						int input_pixel_index = (int) (stbir__edge_wrap((int) (edge_horizontal), (int) (x), (int) (input_w))*channels);
						for (c = (int) (0); (c) < (channels); c++)
						{
							decode_buffer[decode_pixel_index + c] =
								((float) (((double) (((uint*) (input_data))[input_pixel_index + c]))/4294967295));
						}
					}
					break;
				case ((STBIR_TYPE_UINT32)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (; (x) < (max_x); x++)
					{
						int decode_pixel_index = (int) (x*channels);
						int input_pixel_index = (int) (stbir__edge_wrap((int) (edge_horizontal), (int) (x), (int) (input_w))*channels);
						for (c = (int) (0); (c) < (channels); c++)
						{
							decode_buffer[decode_pixel_index + c] =
								(float) (stbir__srgb_to_linear((float) (((double) (((uint*) (input_data))[input_pixel_index + c]))/4294967295)));
						}
						if ((stbir_info.flags & (1 << 1)) == 0)
							decode_buffer[decode_pixel_index + alpha_channel] =
								((float) (((double) (((uint*) (input_data))[input_pixel_index + alpha_channel]))/4294967295));
					}
					break;
				case ((STBIR_TYPE_FLOAT)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (; (x) < (max_x); x++)
					{
						int decode_pixel_index = (int) (x*channels);
						int input_pixel_index = (int) (stbir__edge_wrap((int) (edge_horizontal), (int) (x), (int) (input_w))*channels);
						for (c = (int) (0); (c) < (channels); c++)
						{
							decode_buffer[decode_pixel_index + c] = (float) (((float*) (input_data))[input_pixel_index + c]);
						}
					}
					break;
				case ((STBIR_TYPE_FLOAT)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (; (x) < (max_x); x++)
					{
						int decode_pixel_index = (int) (x*channels);
						int input_pixel_index = (int) (stbir__edge_wrap((int) (edge_horizontal), (int) (x), (int) (input_w))*channels);
						for (c = (int) (0); (c) < (channels); c++)
						{
							decode_buffer[decode_pixel_index + c] =
								(float) (stbir__srgb_to_linear((float) (((float*) (input_data))[input_pixel_index + c])));
						}
						if ((stbir_info.flags & (1 << 1)) == 0)
							decode_buffer[decode_pixel_index + alpha_channel] =
								(float) (((float*) (input_data))[input_pixel_index + alpha_channel]);
					}
					break;
				default:
					;
					break;
			}

			if ((stbir_info.flags & (1 << 0)) == 0)
			{
				for (x = (int) (-stbir_info.horizontal_filter_pixel_margin); (x) < (max_x); x++)
				{
					int decode_pixel_index = (int) (x*channels);
					float alpha = (float) (decode_buffer[decode_pixel_index + alpha_channel]);
					if (stbir_info.type != STBIR_TYPE_FLOAT)
					{
						alpha += (float) ((float) (1)/(1 << 20)/(1 << 20)/(1 << 20)/(1 << 20));
						decode_buffer[decode_pixel_index + alpha_channel] = (float) (alpha);
					}
					for (c = (int) (0); (c) < (channels); c++)
					{
						if ((c) == (alpha_channel)) ;
						decode_buffer[decode_pixel_index + c] *= (float) (alpha);
					}
				}
			}

			if ((edge_horizontal) == (STBIR_EDGE_ZERO))
			{
				for (x = (int) (-stbir_info.horizontal_filter_pixel_margin); (x) < (0); x++)
				{
					for (c = (int) (0); (c) < (channels); c++)
					{
						decode_buffer[x*channels + c] = (float) (0);
					}
				}
				for (x = (int) (input_w); (x) < (max_x); x++)
				{
					for (c = (int) (0); (c) < (channels); c++)
					{
						decode_buffer[x*channels + c] = (float) (0);
					}
				}
			}

		}

		public static float* stbir__get_ring_buffer_entry(float* ring_buffer, int index, int ring_buffer_length)
		{
			return &ring_buffer[index*ring_buffer_length];
		}

		public static float* stbir__add_empty_ring_buffer_entry(stbir__info stbir_info, int n)
		{
			int ring_buffer_index;
			float* ring_buffer;
			stbir_info.ring_buffer_last_scanline = (int) (n);
			if ((stbir_info.ring_buffer_begin_index) < (0))
			{
				ring_buffer_index = (int) (stbir_info.ring_buffer_begin_index = (int) (0));
				stbir_info.ring_buffer_first_scanline = (int) (n);
			}
			else
			{
				ring_buffer_index =
					(int)
						((stbir_info.ring_buffer_begin_index +
						  (stbir_info.ring_buffer_last_scanline - stbir_info.ring_buffer_first_scanline))%
						 stbir_info.ring_buffer_num_entries);
			}

			ring_buffer = stbir__get_ring_buffer_entry(stbir_info.ring_buffer, (int) (ring_buffer_index),
				(int) (stbir_info.ring_buffer_length_bytes/sizeof (float)));
			memset(ring_buffer, (int) (0), (ulong) (stbir_info.ring_buffer_length_bytes));
			return ring_buffer;
		}

		public static void stbir__resample_horizontal_upsample(stbir__info stbir_info, int n, float* output_buffer)
		{
			int x;
			int k;
			int output_w = (int) (stbir_info.output_w);
			int kernel_pixel_width = (int) (stbir_info.horizontal_filter_pixel_width);
			int channels = (int) (stbir_info.channels);
			float* decode_buffer = stbir__get_decode_buffer(stbir_info);
			stbir__contributors* horizontal_contributors = stbir_info.horizontal_contributors;
			float* horizontal_coefficients = stbir_info.horizontal_coefficients;
			int coefficient_width = (int) (stbir_info.horizontal_coefficient_width);
			for (x = (int) (0); (x) < (output_w); x++)
			{
				int n0 = (int) (horizontal_contributors[x].n0);
				int n1 = (int) (horizontal_contributors[x].n1);
				int out_pixel_index = (int) (x*channels);
				int coefficient_group = (int) (coefficient_width*x);
				int coefficient_counter = (int) (0);
				switch (channels)
				{
					case 1:
						for (k = (int) (n0); k <= n1; k++)
						{
							int in_pixel_index = (int) (k*1);
							float coefficient = (float) (horizontal_coefficients[coefficient_group + coefficient_counter++]);
							output_buffer[out_pixel_index + 0] += (float) (decode_buffer[in_pixel_index + 0]*coefficient);
						}
						break;
					case 2:
						for (k = (int) (n0); k <= n1; k++)
						{
							int in_pixel_index = (int) (k*2);
							float coefficient = (float) (horizontal_coefficients[coefficient_group + coefficient_counter++]);
							output_buffer[out_pixel_index + 0] += (float) (decode_buffer[in_pixel_index + 0]*coefficient);
							output_buffer[out_pixel_index + 1] += (float) (decode_buffer[in_pixel_index + 1]*coefficient);
						}
						break;
					case 3:
						for (k = (int) (n0); k <= n1; k++)
						{
							int in_pixel_index = (int) (k*3);
							float coefficient = (float) (horizontal_coefficients[coefficient_group + coefficient_counter++]);
							output_buffer[out_pixel_index + 0] += (float) (decode_buffer[in_pixel_index + 0]*coefficient);
							output_buffer[out_pixel_index + 1] += (float) (decode_buffer[in_pixel_index + 1]*coefficient);
							output_buffer[out_pixel_index + 2] += (float) (decode_buffer[in_pixel_index + 2]*coefficient);
						}
						break;
					case 4:
						for (k = (int) (n0); k <= n1; k++)
						{
							int in_pixel_index = (int) (k*4);
							float coefficient = (float) (horizontal_coefficients[coefficient_group + coefficient_counter++]);
							output_buffer[out_pixel_index + 0] += (float) (decode_buffer[in_pixel_index + 0]*coefficient);
							output_buffer[out_pixel_index + 1] += (float) (decode_buffer[in_pixel_index + 1]*coefficient);
							output_buffer[out_pixel_index + 2] += (float) (decode_buffer[in_pixel_index + 2]*coefficient);
							output_buffer[out_pixel_index + 3] += (float) (decode_buffer[in_pixel_index + 3]*coefficient);
						}
						break;
					default:
						for (k = (int) (n0); k <= n1; k++)
						{
							int in_pixel_index = (int) (k*channels);
							float coefficient = (float) (horizontal_coefficients[coefficient_group + coefficient_counter++]);
							int c;
							for (c = (int) (0); (c) < (channels); c++)
							{
								output_buffer[out_pixel_index + c] += (float) (decode_buffer[in_pixel_index + c]*coefficient);
							}
						}
						break;
				}
			}
		}

		public static void stbir__resample_horizontal_downsample(stbir__info stbir_info, int n, float* output_buffer)
		{
			int x;
			int k;
			int input_w = (int) (stbir_info.input_w);
			int output_w = (int) (stbir_info.output_w);
			int kernel_pixel_width = (int) (stbir_info.horizontal_filter_pixel_width);
			int channels = (int) (stbir_info.channels);
			float* decode_buffer = stbir__get_decode_buffer(stbir_info);
			stbir__contributors* horizontal_contributors = stbir_info.horizontal_contributors;
			float* horizontal_coefficients = stbir_info.horizontal_coefficients;
			int coefficient_width = (int) (stbir_info.horizontal_coefficient_width);
			int filter_pixel_margin = (int) (stbir_info.horizontal_filter_pixel_margin);
			int max_x = (int) (input_w + filter_pixel_margin*2);
			switch (channels)
			{
				case 1:
					for (x = (int) (0); (x) < (max_x); x++)
					{
						int n0 = (int) (horizontal_contributors[x].n0);
						int n1 = (int) (horizontal_contributors[x].n1);
						int in_x = (int) (x - filter_pixel_margin);
						int in_pixel_index = (int) (in_x*1);
						int max_n = (int) (n1);
						int coefficient_group = (int) (coefficient_width*x);
						for (k = (int) (n0); k <= max_n; k++)
						{
							int out_pixel_index = (int) (k*1);
							float coefficient = (float) (horizontal_coefficients[coefficient_group + k - n0]);
							output_buffer[out_pixel_index + 0] += (float) (decode_buffer[in_pixel_index + 0]*coefficient);
						}
					}
					break;
				case 2:
					for (x = (int) (0); (x) < (max_x); x++)
					{
						int n0 = (int) (horizontal_contributors[x].n0);
						int n1 = (int) (horizontal_contributors[x].n1);
						int in_x = (int) (x - filter_pixel_margin);
						int in_pixel_index = (int) (in_x*2);
						int max_n = (int) (n1);
						int coefficient_group = (int) (coefficient_width*x);
						for (k = (int) (n0); k <= max_n; k++)
						{
							int out_pixel_index = (int) (k*2);
							float coefficient = (float) (horizontal_coefficients[coefficient_group + k - n0]);
							output_buffer[out_pixel_index + 0] += (float) (decode_buffer[in_pixel_index + 0]*coefficient);
							output_buffer[out_pixel_index + 1] += (float) (decode_buffer[in_pixel_index + 1]*coefficient);
						}
					}
					break;
				case 3:
					for (x = (int) (0); (x) < (max_x); x++)
					{
						int n0 = (int) (horizontal_contributors[x].n0);
						int n1 = (int) (horizontal_contributors[x].n1);
						int in_x = (int) (x - filter_pixel_margin);
						int in_pixel_index = (int) (in_x*3);
						int max_n = (int) (n1);
						int coefficient_group = (int) (coefficient_width*x);
						for (k = (int) (n0); k <= max_n; k++)
						{
							int out_pixel_index = (int) (k*3);
							float coefficient = (float) (horizontal_coefficients[coefficient_group + k - n0]);
							output_buffer[out_pixel_index + 0] += (float) (decode_buffer[in_pixel_index + 0]*coefficient);
							output_buffer[out_pixel_index + 1] += (float) (decode_buffer[in_pixel_index + 1]*coefficient);
							output_buffer[out_pixel_index + 2] += (float) (decode_buffer[in_pixel_index + 2]*coefficient);
						}
					}
					break;
				case 4:
					for (x = (int) (0); (x) < (max_x); x++)
					{
						int n0 = (int) (horizontal_contributors[x].n0);
						int n1 = (int) (horizontal_contributors[x].n1);
						int in_x = (int) (x - filter_pixel_margin);
						int in_pixel_index = (int) (in_x*4);
						int max_n = (int) (n1);
						int coefficient_group = (int) (coefficient_width*x);
						for (k = (int) (n0); k <= max_n; k++)
						{
							int out_pixel_index = (int) (k*4);
							float coefficient = (float) (horizontal_coefficients[coefficient_group + k - n0]);
							output_buffer[out_pixel_index + 0] += (float) (decode_buffer[in_pixel_index + 0]*coefficient);
							output_buffer[out_pixel_index + 1] += (float) (decode_buffer[in_pixel_index + 1]*coefficient);
							output_buffer[out_pixel_index + 2] += (float) (decode_buffer[in_pixel_index + 2]*coefficient);
							output_buffer[out_pixel_index + 3] += (float) (decode_buffer[in_pixel_index + 3]*coefficient);
						}
					}
					break;
				default:
					for (x = (int) (0); (x) < (max_x); x++)
					{
						int n0 = (int) (horizontal_contributors[x].n0);
						int n1 = (int) (horizontal_contributors[x].n1);
						int in_x = (int) (x - filter_pixel_margin);
						int in_pixel_index = (int) (in_x*channels);
						int max_n = (int) (n1);
						int coefficient_group = (int) (coefficient_width*x);
						for (k = (int) (n0); k <= max_n; k++)
						{
							int c;
							int out_pixel_index = (int) (k*channels);
							float coefficient = (float) (horizontal_coefficients[coefficient_group + k - n0]);
							for (c = (int) (0); (c) < (channels); c++)
							{
								output_buffer[out_pixel_index + c] += (float) (decode_buffer[in_pixel_index + c]*coefficient);
							}
						}
					}
					break;
			}

		}

		public static void stbir__decode_and_resample_upsample(stbir__info stbir_info, int n)
		{
			stbir__decode_scanline(stbir_info, (int) (n));
			if ((stbir__use_width_upsampling(stbir_info)) != 0)
				stbir__resample_horizontal_upsample(stbir_info, (int) (n), stbir__add_empty_ring_buffer_entry(stbir_info, (int) (n)));
			else
				stbir__resample_horizontal_downsample(stbir_info, (int) (n),
					stbir__add_empty_ring_buffer_entry(stbir_info, (int) (n)));
		}

		public static void stbir__decode_and_resample_downsample(stbir__info stbir_info, int n)
		{
			stbir__decode_scanline(stbir_info, (int) (n));
			memset(stbir_info.horizontal_buffer, (int) (0), (ulong) (stbir_info.output_w*stbir_info.channels*sizeof (float)));
			if ((stbir__use_width_upsampling(stbir_info)) != 0)
				stbir__resample_horizontal_upsample(stbir_info, (int) (n), stbir_info.horizontal_buffer);
			else stbir__resample_horizontal_downsample(stbir_info, (int) (n), stbir_info.horizontal_buffer);
		}

		public static float* stbir__get_ring_buffer_scanline(int get_scanline, float* ring_buffer, int begin_index,
			int first_scanline, int ring_buffer_num_entries, int ring_buffer_length)
		{
			int ring_buffer_index = (int) ((begin_index + (get_scanline - first_scanline))%ring_buffer_num_entries);
			return stbir__get_ring_buffer_entry(ring_buffer, (int) (ring_buffer_index), (int) (ring_buffer_length));
		}

		public static void stbir__encode_scanline(stbir__info stbir_info, int num_pixels, void* output_buffer,
			float* encode_buffer, int channels, int alpha_channel, int decode)
		{
			int x;
			int n;
			int num_nonalpha;
			ushort* nonalpha = stackalloc ushort[64];
			if ((stbir_info.flags & (1 << 0)) == 0)
			{
				for (x = (int) (0); (x) < (num_pixels); ++x)
				{
					int pixel_index = (int) (x*channels);
					float alpha = (float) (encode_buffer[pixel_index + alpha_channel]);
					float reciprocal_alpha = (float) ((alpha) != 0 ? 1.0f/alpha : 0);
					for (n = (int) (0); (n) < (channels); n++)
					{
						if (n != alpha_channel) encode_buffer[pixel_index + n] *= (float) (reciprocal_alpha);
					}
				}
			}

			for (x = (int) (0) , num_nonalpha = (int) (0); (x) < (channels); ++x)
			{
				if ((x != alpha_channel) || (stbir_info.flags & (1 << 1)) != 0) nonalpha[num_nonalpha++] = (ushort) (x);
			}
			switch (decode)
			{
				case ((STBIR_TYPE_UINT8)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (x = (int) (0); (x) < (num_pixels); ++x)
					{
						int pixel_index = (int) (x*channels);
						for (n = (int) (0); (n) < (channels); n++)
						{
							int index = (int) (pixel_index + n);
							((byte*) (output_buffer))[index] = ((byte) ((int) ((stbir__saturate((float) (encode_buffer[index]))*255) + 0.5)));
						}
					}
					break;
				case ((STBIR_TYPE_UINT8)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (x = (int) (0); (x) < (num_pixels); ++x)
					{
						int pixel_index = (int) (x*channels);
						for (n = (int) (0); (n) < (num_nonalpha); n++)
						{
							int index = (int) (pixel_index + nonalpha[n]);
							((byte*) (output_buffer))[index] = (byte) (stbir__linear_to_srgb_uchar((float) (encode_buffer[index])));
						}
						if ((stbir_info.flags & (1 << 1)) == 0)
							((byte*) (output_buffer))[pixel_index + alpha_channel] =
								((byte) ((int) ((stbir__saturate((float) (encode_buffer[pixel_index + alpha_channel]))*255) + 0.5)));
					}
					break;
				case ((STBIR_TYPE_UINT16)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (x = (int) (0); (x) < (num_pixels); ++x)
					{
						int pixel_index = (int) (x*channels);
						for (n = (int) (0); (n) < (channels); n++)
						{
							int index = (int) (pixel_index + n);
							((ushort*) (output_buffer))[index] =
								((ushort) ((int) ((stbir__saturate((float) (encode_buffer[index]))*65535) + 0.5)));
						}
					}
					break;
				case ((STBIR_TYPE_UINT16)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (x = (int) (0); (x) < (num_pixels); ++x)
					{
						int pixel_index = (int) (x*channels);
						for (n = (int) (0); (n) < (num_nonalpha); n++)
						{
							int index = (int) (pixel_index + nonalpha[n]);
							((ushort*) (output_buffer))[index] =
								((ushort)
									((int) ((stbir__linear_to_srgb((float) (stbir__saturate((float) (encode_buffer[index]))))*65535) + 0.5)));
						}
						if ((stbir_info.flags & (1 << 1)) == 0)
							((ushort*) (output_buffer))[pixel_index + alpha_channel] =
								((ushort) ((int) ((stbir__saturate((float) (encode_buffer[pixel_index + alpha_channel]))*65535) + 0.5)));
					}
					break;
				case ((STBIR_TYPE_UINT32)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (x = (int) (0); (x) < (num_pixels); ++x)
					{
						int pixel_index = (int) (x*channels);
						for (n = (int) (0); (n) < (channels); n++)
						{
							int index = (int) (pixel_index + n);
							((uint*) (output_buffer))[index] =
								((uint) ((((double) (stbir__saturate((float) (encode_buffer[index]))))*4294967295) + 0.5));
						}
					}
					break;
				case ((STBIR_TYPE_UINT32)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (x = (int) (0); (x) < (num_pixels); ++x)
					{
						int pixel_index = (int) (x*channels);
						for (n = (int) (0); (n) < (num_nonalpha); n++)
						{
							int index = (int) (pixel_index + nonalpha[n]);
							((uint*) (output_buffer))[index] =
								((uint)
									((((double) (stbir__linear_to_srgb((float) (stbir__saturate((float) (encode_buffer[index]))))))*4294967295) +
									 0.5));
						}
						if ((stbir_info.flags & (1 << 1)) == 0)
							((uint*) (output_buffer))[pixel_index + alpha_channel] =
								((uint)
									((int) ((((double) (stbir__saturate((float) (encode_buffer[pixel_index + alpha_channel]))))*4294967295) + 0.5)));
					}
					break;
				case ((STBIR_TYPE_FLOAT)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (x = (int) (0); (x) < (num_pixels); ++x)
					{
						int pixel_index = (int) (x*channels);
						for (n = (int) (0); (n) < (channels); n++)
						{
							int index = (int) (pixel_index + n);
							((float*) (output_buffer))[index] = (float) (encode_buffer[index]);
						}
					}
					break;
				case ((STBIR_TYPE_FLOAT)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (x = (int) (0); (x) < (num_pixels); ++x)
					{
						int pixel_index = (int) (x*channels);
						for (n = (int) (0); (n) < (num_nonalpha); n++)
						{
							int index = (int) (pixel_index + nonalpha[n]);
							((float*) (output_buffer))[index] = (float) (stbir__linear_to_srgb((float) (encode_buffer[index])));
						}
						if ((stbir_info.flags & (1 << 1)) == 0)
							((float*) (output_buffer))[pixel_index + alpha_channel] = (float) (encode_buffer[pixel_index + alpha_channel]);
					}
					break;
				default:
					;
					break;
			}

		}

		public static void stbir__resample_vertical_upsample(stbir__info stbir_info, int n, int in_first_scanline,
			int in_last_scanline, float in_center_of_out)
		{
			int x;
			int k;
			int output_w = (int) (stbir_info.output_w);
			stbir__contributors* vertical_contributors = stbir_info.vertical_contributors;
			float* vertical_coefficients = stbir_info.vertical_coefficients;
			int channels = (int) (stbir_info.channels);
			int alpha_channel = (int) (stbir_info.alpha_channel);
			int type = (int) (stbir_info.type);
			int colorspace = (int) (stbir_info.colorspace);
			int ring_buffer_entries = (int) (stbir_info.ring_buffer_num_entries);
			void* output_data = stbir_info.output_data;
			float* encode_buffer = stbir_info.encode_buffer;
			int decode = (int) ((type)*(STBIR_MAX_COLORSPACES) + (colorspace));
			int coefficient_width = (int) (stbir_info.vertical_coefficient_width);
			int coefficient_counter;
			int contributor = (int) (n);
			float* ring_buffer = stbir_info.ring_buffer;
			int ring_buffer_begin_index = (int) (stbir_info.ring_buffer_begin_index);
			int ring_buffer_first_scanline = (int) (stbir_info.ring_buffer_first_scanline);
			int ring_buffer_last_scanline = (int) (stbir_info.ring_buffer_last_scanline);
			int ring_buffer_length = (int) (stbir_info.ring_buffer_length_bytes/sizeof (float));
			int n0;
			int n1;
			int output_row_start;
			int coefficient_group = (int) (coefficient_width*contributor);
			n0 = (int) (vertical_contributors[contributor].n0);
			n1 = (int) (vertical_contributors[contributor].n1);
			output_row_start = (int) (n*stbir_info.output_stride_bytes);
			memset(encode_buffer, (int) (0), (ulong) (output_w*sizeof (float)*channels));
			coefficient_counter = (int) (0);
			switch (channels)
			{
				case 1:
					for (k = (int) (n0); k <= n1; k++)
					{
						int coefficient_index = (int) (coefficient_counter++);
						float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int) (k), ring_buffer, (int) (ring_buffer_begin_index),
							(int) (ring_buffer_first_scanline), (int) (ring_buffer_entries), (int) (ring_buffer_length));
						float coefficient = (float) (vertical_coefficients[coefficient_group + coefficient_index]);
						for (x = (int) (0); (x) < (output_w); ++x)
						{
							int in_pixel_index = (int) (x*1);
							encode_buffer[in_pixel_index + 0] += (float) (ring_buffer_entry[in_pixel_index + 0]*coefficient);
						}
					}
					break;
				case 2:
					for (k = (int) (n0); k <= n1; k++)
					{
						int coefficient_index = (int) (coefficient_counter++);
						float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int) (k), ring_buffer, (int) (ring_buffer_begin_index),
							(int) (ring_buffer_first_scanline), (int) (ring_buffer_entries), (int) (ring_buffer_length));
						float coefficient = (float) (vertical_coefficients[coefficient_group + coefficient_index]);
						for (x = (int) (0); (x) < (output_w); ++x)
						{
							int in_pixel_index = (int) (x*2);
							encode_buffer[in_pixel_index + 0] += (float) (ring_buffer_entry[in_pixel_index + 0]*coefficient);
							encode_buffer[in_pixel_index + 1] += (float) (ring_buffer_entry[in_pixel_index + 1]*coefficient);
						}
					}
					break;
				case 3:
					for (k = (int) (n0); k <= n1; k++)
					{
						int coefficient_index = (int) (coefficient_counter++);
						float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int) (k), ring_buffer, (int) (ring_buffer_begin_index),
							(int) (ring_buffer_first_scanline), (int) (ring_buffer_entries), (int) (ring_buffer_length));
						float coefficient = (float) (vertical_coefficients[coefficient_group + coefficient_index]);
						for (x = (int) (0); (x) < (output_w); ++x)
						{
							int in_pixel_index = (int) (x*3);
							encode_buffer[in_pixel_index + 0] += (float) (ring_buffer_entry[in_pixel_index + 0]*coefficient);
							encode_buffer[in_pixel_index + 1] += (float) (ring_buffer_entry[in_pixel_index + 1]*coefficient);
							encode_buffer[in_pixel_index + 2] += (float) (ring_buffer_entry[in_pixel_index + 2]*coefficient);
						}
					}
					break;
				case 4:
					for (k = (int) (n0); k <= n1; k++)
					{
						int coefficient_index = (int) (coefficient_counter++);
						float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int) (k), ring_buffer, (int) (ring_buffer_begin_index),
							(int) (ring_buffer_first_scanline), (int) (ring_buffer_entries), (int) (ring_buffer_length));
						float coefficient = (float) (vertical_coefficients[coefficient_group + coefficient_index]);
						for (x = (int) (0); (x) < (output_w); ++x)
						{
							int in_pixel_index = (int) (x*4);
							encode_buffer[in_pixel_index + 0] += (float) (ring_buffer_entry[in_pixel_index + 0]*coefficient);
							encode_buffer[in_pixel_index + 1] += (float) (ring_buffer_entry[in_pixel_index + 1]*coefficient);
							encode_buffer[in_pixel_index + 2] += (float) (ring_buffer_entry[in_pixel_index + 2]*coefficient);
							encode_buffer[in_pixel_index + 3] += (float) (ring_buffer_entry[in_pixel_index + 3]*coefficient);
						}
					}
					break;
				default:
					for (k = (int) (n0); k <= n1; k++)
					{
						int coefficient_index = (int) (coefficient_counter++);
						float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int) (k), ring_buffer, (int) (ring_buffer_begin_index),
							(int) (ring_buffer_first_scanline), (int) (ring_buffer_entries), (int) (ring_buffer_length));
						float coefficient = (float) (vertical_coefficients[coefficient_group + coefficient_index]);
						for (x = (int) (0); (x) < (output_w); ++x)
						{
							int in_pixel_index = (int) (x*channels);
							int c;
							for (c = (int) (0); (c) < (channels); c++)
							{
								encode_buffer[in_pixel_index + c] += (float) (ring_buffer_entry[in_pixel_index + c]*coefficient);
							}
						}
					}
					break;
			}

			stbir__encode_scanline(stbir_info, (int) (output_w), (sbyte*) (output_data) + output_row_start, encode_buffer,
				(int) (channels), (int) (alpha_channel), (int) (decode));
		}

		public static void stbir__resample_vertical_downsample(stbir__info stbir_info, int n, int in_first_scanline,
			int in_last_scanline, float in_center_of_out)
		{
			int x;
			int k;
			int output_w = (int) (stbir_info.output_w);
			int output_h = (int) (stbir_info.output_h);
			stbir__contributors* vertical_contributors = stbir_info.vertical_contributors;
			float* vertical_coefficients = stbir_info.vertical_coefficients;
			int channels = (int) (stbir_info.channels);
			int ring_buffer_entries = (int) (stbir_info.ring_buffer_num_entries);
			void* output_data = stbir_info.output_data;
			float* horizontal_buffer = stbir_info.horizontal_buffer;
			int coefficient_width = (int) (stbir_info.vertical_coefficient_width);
			int contributor = (int) (n + stbir_info.vertical_filter_pixel_margin);
			float* ring_buffer = stbir_info.ring_buffer;
			int ring_buffer_begin_index = (int) (stbir_info.ring_buffer_begin_index);
			int ring_buffer_first_scanline = (int) (stbir_info.ring_buffer_first_scanline);
			int ring_buffer_last_scanline = (int) (stbir_info.ring_buffer_last_scanline);
			int ring_buffer_length = (int) (stbir_info.ring_buffer_length_bytes/sizeof (float));
			int n0;
			int n1;
			n0 = (int) (vertical_contributors[contributor].n0);
			n1 = (int) (vertical_contributors[contributor].n1);
			for (k = (int) (n0); k <= n1; k++)
			{
				int coefficient_index = (int) (k - n0);
				int coefficient_group = (int) (coefficient_width*contributor);
				float coefficient = (float) (vertical_coefficients[coefficient_group + coefficient_index]);
				float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int) (k), ring_buffer, (int) (ring_buffer_begin_index),
					(int) (ring_buffer_first_scanline), (int) (ring_buffer_entries), (int) (ring_buffer_length));
				switch (channels)
				{
					case 1:
						for (x = (int) (0); (x) < (output_w); x++)
						{
							int in_pixel_index = (int) (x*1);
							ring_buffer_entry[in_pixel_index + 0] += (float) (horizontal_buffer[in_pixel_index + 0]*coefficient);
						}
						break;
					case 2:
						for (x = (int) (0); (x) < (output_w); x++)
						{
							int in_pixel_index = (int) (x*2);
							ring_buffer_entry[in_pixel_index + 0] += (float) (horizontal_buffer[in_pixel_index + 0]*coefficient);
							ring_buffer_entry[in_pixel_index + 1] += (float) (horizontal_buffer[in_pixel_index + 1]*coefficient);
						}
						break;
					case 3:
						for (x = (int) (0); (x) < (output_w); x++)
						{
							int in_pixel_index = (int) (x*3);
							ring_buffer_entry[in_pixel_index + 0] += (float) (horizontal_buffer[in_pixel_index + 0]*coefficient);
							ring_buffer_entry[in_pixel_index + 1] += (float) (horizontal_buffer[in_pixel_index + 1]*coefficient);
							ring_buffer_entry[in_pixel_index + 2] += (float) (horizontal_buffer[in_pixel_index + 2]*coefficient);
						}
						break;
					case 4:
						for (x = (int) (0); (x) < (output_w); x++)
						{
							int in_pixel_index = (int) (x*4);
							ring_buffer_entry[in_pixel_index + 0] += (float) (horizontal_buffer[in_pixel_index + 0]*coefficient);
							ring_buffer_entry[in_pixel_index + 1] += (float) (horizontal_buffer[in_pixel_index + 1]*coefficient);
							ring_buffer_entry[in_pixel_index + 2] += (float) (horizontal_buffer[in_pixel_index + 2]*coefficient);
							ring_buffer_entry[in_pixel_index + 3] += (float) (horizontal_buffer[in_pixel_index + 3]*coefficient);
						}
						break;
					default:
						for (x = (int) (0); (x) < (output_w); x++)
						{
							int in_pixel_index = (int) (x*channels);
							int c;
							for (c = (int) (0); (c) < (channels); c++)
							{
								ring_buffer_entry[in_pixel_index + c] += (float) (horizontal_buffer[in_pixel_index + c]*coefficient);
							}
						}
						break;
				}
			}
		}

		public static void stbir__buffer_loop_upsample(stbir__info stbir_info)
		{
			int y;
			float scale_ratio = (float) (stbir_info.vertical_scale);
			float out_scanlines_radius =
				(float) (stbir__filter_info_table[stbir_info.vertical_filter].support((float) (1/scale_ratio))*scale_ratio);
			for (y = (int) (0); (y) < (stbir_info.output_h); y++)
			{
				float in_center_of_out = (float) (0);
				int in_first_scanline = (int) (0);
				int in_last_scanline = (int) (0);
				stbir__calculate_sample_range_upsample((int) (y), (float) (out_scanlines_radius), (float) (scale_ratio),
					(float) (stbir_info.vertical_shift), &in_first_scanline, &in_last_scanline, &in_center_of_out);
				if ((stbir_info.ring_buffer_begin_index) >= (0))
				{
					while ((in_first_scanline) > (stbir_info.ring_buffer_first_scanline))
					{
						if ((stbir_info.ring_buffer_first_scanline) == (stbir_info.ring_buffer_last_scanline))
						{
							stbir_info.ring_buffer_begin_index = (int) (-1);
							stbir_info.ring_buffer_first_scanline = (int) (0);
							stbir_info.ring_buffer_last_scanline = (int) (0);
							break;
						}
						else
						{
							stbir_info.ring_buffer_first_scanline++;
							stbir_info.ring_buffer_begin_index =
								(int) ((stbir_info.ring_buffer_begin_index + 1)%stbir_info.ring_buffer_num_entries);
						}
					}
				}
				if ((stbir_info.ring_buffer_begin_index) < (0))
					stbir__decode_and_resample_upsample(stbir_info, (int) (in_first_scanline));
				while ((in_last_scanline) > (stbir_info.ring_buffer_last_scanline))
				{
					stbir__decode_and_resample_upsample(stbir_info, (int) (stbir_info.ring_buffer_last_scanline + 1));
				}
				stbir__resample_vertical_upsample(stbir_info, (int) (y), (int) (in_first_scanline), (int) (in_last_scanline),
					(float) (in_center_of_out));
			}
		}

		public static void stbir__empty_ring_buffer(stbir__info stbir_info, int first_necessary_scanline)
		{
			int output_stride_bytes = (int) (stbir_info.output_stride_bytes);
			int channels = (int) (stbir_info.channels);
			int alpha_channel = (int) (stbir_info.alpha_channel);
			int type = (int) (stbir_info.type);
			int colorspace = (int) (stbir_info.colorspace);
			int output_w = (int) (stbir_info.output_w);
			void* output_data = stbir_info.output_data;
			int decode = (int) ((type)*(STBIR_MAX_COLORSPACES) + (colorspace));
			float* ring_buffer = stbir_info.ring_buffer;
			int ring_buffer_length = (int) (stbir_info.ring_buffer_length_bytes/sizeof (float));
			if ((stbir_info.ring_buffer_begin_index) >= (0))
			{
				while ((first_necessary_scanline) > (stbir_info.ring_buffer_first_scanline))
				{
					if (((stbir_info.ring_buffer_first_scanline) >= (0)) &&
					    ((stbir_info.ring_buffer_first_scanline) < (stbir_info.output_h)))
					{
						int output_row_start = (int) (stbir_info.ring_buffer_first_scanline*output_stride_bytes);
						float* ring_buffer_entry = stbir__get_ring_buffer_entry(ring_buffer, (int) (stbir_info.ring_buffer_begin_index),
							(int) (ring_buffer_length));
						stbir__encode_scanline(stbir_info, (int) (output_w), (sbyte*) (output_data) + output_row_start, ring_buffer_entry,
							(int) (channels), (int) (alpha_channel), (int) (decode));
					}
					if ((stbir_info.ring_buffer_first_scanline) == (stbir_info.ring_buffer_last_scanline))
					{
						stbir_info.ring_buffer_begin_index = (int) (-1);
						stbir_info.ring_buffer_first_scanline = (int) (0);
						stbir_info.ring_buffer_last_scanline = (int) (0);
						break;
					}
					else
					{
						stbir_info.ring_buffer_first_scanline++;
						stbir_info.ring_buffer_begin_index =
							(int) ((stbir_info.ring_buffer_begin_index + 1)%stbir_info.ring_buffer_num_entries);
					}
				}
			}

		}

		public static void stbir__buffer_loop_downsample(stbir__info stbir_info)
		{
			int y;
			float scale_ratio = (float) (stbir_info.vertical_scale);
			int output_h = (int) (stbir_info.output_h);
			float in_pixels_radius =
				(float) (stbir__filter_info_table[stbir_info.vertical_filter].support((float) (scale_ratio))/scale_ratio);
			int pixel_margin = (int) (stbir_info.vertical_filter_pixel_margin);
			int max_y = (int) (stbir_info.input_h + pixel_margin);
			for (y = (int) (-pixel_margin); (y) < (max_y); y++)
			{
				float out_center_of_in;
				int out_first_scanline;
				int out_last_scanline;
				stbir__calculate_sample_range_downsample((int) (y), (float) (in_pixels_radius), (float) (scale_ratio),
					(float) (stbir_info.vertical_shift), &out_first_scanline, &out_last_scanline, &out_center_of_in);
				if (((out_last_scanline) < (0)) || ((out_first_scanline) >= (output_h))) ;
				stbir__empty_ring_buffer(stbir_info, (int) (out_first_scanline));
				stbir__decode_and_resample_downsample(stbir_info, (int) (y));
				if ((stbir_info.ring_buffer_begin_index) < (0))
					stbir__add_empty_ring_buffer_entry(stbir_info, (int) (out_first_scanline));
				while ((out_last_scanline) > (stbir_info.ring_buffer_last_scanline))
				{
					stbir__add_empty_ring_buffer_entry(stbir_info, (int) (stbir_info.ring_buffer_last_scanline + 1));
				}
				stbir__resample_vertical_downsample(stbir_info, (int) (y), (int) (out_first_scanline), (int) (out_last_scanline),
					(float) (out_center_of_in));
			}
			stbir__empty_ring_buffer(stbir_info, (int) (stbir_info.output_h));
		}

		public static void stbir__setup(stbir__info info, int input_w, int input_h, int output_w, int output_h, int channels)
		{
			info.input_w = (int) (input_w);
			info.input_h = (int) (input_h);
			info.output_w = (int) (output_w);
			info.output_h = (int) (output_h);
			info.channels = (int) (channels);
		}

		public static void stbir__calculate_transform(stbir__info info, float s0, float t0, float s1, float t1,
			float* transform)
		{
			info.s0 = (float) (s0);
			info.t0 = (float) (t0);
			info.s1 = (float) (s1);
			info.t1 = (float) (t1);
			if ((transform) != null)
			{
				info.horizontal_scale = (float) (transform[0]);
				info.vertical_scale = (float) (transform[1]);
				info.horizontal_shift = (float) (transform[2]);
				info.vertical_shift = (float) (transform[3]);
			}
			else
			{
				info.horizontal_scale = (float) (((float) (info.output_w)/info.input_w)/(s1 - s0));
				info.vertical_scale = (float) (((float) (info.output_h)/info.input_h)/(t1 - t0));
				info.horizontal_shift = (float) (s0*info.output_w/(s1 - s0));
				info.vertical_shift = (float) (t0*info.output_h/(t1 - t0));
			}

		}

		public static void stbir__choose_filter(stbir__info info, int h_filter, int v_filter)
		{
			if ((h_filter) == (0))
				h_filter =
					(int)
						((stbir__use_upsampling((float) (info.horizontal_scale))) != 0 ? STBIR_FILTER_CATMULLROM : STBIR_FILTER_MITCHELL);
			if ((v_filter) == (0))
				v_filter =
					(int)
						((stbir__use_upsampling((float) (info.vertical_scale))) != 0 ? STBIR_FILTER_CATMULLROM : STBIR_FILTER_MITCHELL);
			info.horizontal_filter = (int) (h_filter);
			info.vertical_filter = (int) (v_filter);
		}

		public static uint stbir__calculate_memory(stbir__info info)
		{
			int pixel_margin =
				(int) (stbir__get_filter_pixel_margin((int) (info.horizontal_filter), (float) (info.horizontal_scale)));
			int filter_height =
				(int) (stbir__get_filter_pixel_width((int) (info.vertical_filter), (float) (info.vertical_scale)));
			info.horizontal_num_contributors =
				(int)
					(stbir__get_contributors((float) (info.horizontal_scale), (int) (info.horizontal_filter), (int) (info.input_w),
						(int) (info.output_w)));
			info.vertical_num_contributors =
				(int)
					(stbir__get_contributors((float) (info.vertical_scale), (int) (info.vertical_filter), (int) (info.input_h),
						(int) (info.output_h)));
			info.ring_buffer_num_entries = (int) (filter_height + 1);
			info.horizontal_contributors_size = (int) (info.horizontal_num_contributors*sizeof (stbir__contributors));
			info.horizontal_coefficients_size = (int) (stbir__get_total_horizontal_coefficients(info)*sizeof (float));
			info.vertical_contributors_size = (int) (info.vertical_num_contributors*sizeof (stbir__contributors));
			info.vertical_coefficients_size = (int) (stbir__get_total_vertical_coefficients(info)*sizeof (float));
			info.decode_buffer_size = (int) ((info.input_w + pixel_margin*2)*info.channels*sizeof (float));
			info.horizontal_buffer_size = (int) (info.output_w*info.channels*sizeof (float));
			info.ring_buffer_size = (int) (info.output_w*info.channels*info.ring_buffer_num_entries*sizeof (float));
			info.encode_buffer_size = (int) (info.output_w*info.channels*sizeof (float));
			if ((stbir__use_height_upsampling(info)) != 0) info.horizontal_buffer_size = (int) (0);
			else info.encode_buffer_size = (int) (0);
			return
				(uint)
					(info.horizontal_contributors_size + info.horizontal_coefficients_size + info.vertical_contributors_size +
					 info.vertical_coefficients_size + info.decode_buffer_size + info.horizontal_buffer_size + info.ring_buffer_size +
					 info.encode_buffer_size);
		}

		public static int stbir__resize_allocated(stbir__info info, void* input_data, int input_stride_in_bytes,
			void* output_data, int output_stride_in_bytes, int alpha_channel, uint flags, int type, int edge_horizontal,
			int edge_vertical, int colorspace, void* tempmem, ulong tempmem_size_in_bytes)
		{
			ulong memory_required = (ulong) (stbir__calculate_memory(info));
			int width_stride_input =
				(int) ((input_stride_in_bytes) != 0 ? input_stride_in_bytes : info.channels*info.input_w*stbir__type_size[type]);
			int width_stride_output =
				(int) ((output_stride_in_bytes) != 0 ? output_stride_in_bytes : info.channels*info.output_w*stbir__type_size[type]);
			if (((info.channels) < (0)) || ((info.channels) > (64))) return (int) (0);
			if ((info.horizontal_filter) >= (6)) return (int) (0);
			if ((info.vertical_filter) >= (6)) return (int) (0);
			if ((alpha_channel) < (0)) flags |= (uint) ((1 << 1) | (1 << 0));
			if (((flags & (1 << 1)) == 0) || ((flags & (1 << 0)) == 0)) ;
			if ((alpha_channel) >= (info.channels)) return (int) (0);
			if (tempmem == null) return (int) (0);
			if ((tempmem_size_in_bytes) < (memory_required)) return (int) (0);
			memset(tempmem, (int) (0), (ulong) (tempmem_size_in_bytes));
			info.input_data = input_data;
			info.input_stride_bytes = (int) (width_stride_input);
			info.output_data = output_data;
			info.output_stride_bytes = (int) (width_stride_output);
			info.alpha_channel = (int) (alpha_channel);
			info.flags = (uint) (flags);
			info.type = (int) (type);
			info.edge_horizontal = (int) (edge_horizontal);
			info.edge_vertical = (int) (edge_vertical);
			info.colorspace = (int) (colorspace);
			info.horizontal_coefficient_width =
				(int) (stbir__get_coefficient_width((int) (info.horizontal_filter), (float) (info.horizontal_scale)));
			info.vertical_coefficient_width =
				(int) (stbir__get_coefficient_width((int) (info.vertical_filter), (float) (info.vertical_scale)));
			info.horizontal_filter_pixel_width =
				(int) (stbir__get_filter_pixel_width((int) (info.horizontal_filter), (float) (info.horizontal_scale)));
			info.vertical_filter_pixel_width =
				(int) (stbir__get_filter_pixel_width((int) (info.vertical_filter), (float) (info.vertical_scale)));
			info.horizontal_filter_pixel_margin =
				(int) (stbir__get_filter_pixel_margin((int) (info.horizontal_filter), (float) (info.horizontal_scale)));
			info.vertical_filter_pixel_margin =
				(int) (stbir__get_filter_pixel_margin((int) (info.vertical_filter), (float) (info.vertical_scale)));
			info.ring_buffer_length_bytes = (int) (info.output_w*info.channels*sizeof (float));
			info.decode_buffer_pixels = (int) (info.input_w + info.horizontal_filter_pixel_margin*2);
			info.horizontal_contributors = (stbir__contributors*) (tempmem);
			info.horizontal_coefficients =
				(float*) (((byte*) (info.horizontal_contributors)) + info.horizontal_contributors_size);
			info.vertical_contributors =
				(stbir__contributors*) (((byte*) (info.horizontal_coefficients)) + info.horizontal_coefficients_size);
			info.vertical_coefficients = (float*) (((byte*) (info.vertical_contributors)) + info.vertical_contributors_size);
			info.decode_buffer = (float*) (((byte*) (info.vertical_coefficients)) + info.vertical_coefficients_size);
			if ((stbir__use_height_upsampling(info)) != 0)
			{
				info.horizontal_buffer = null;
				info.ring_buffer = (float*) (((byte*) (info.decode_buffer)) + info.decode_buffer_size);
				info.encode_buffer = (float*) (((byte*) (info.ring_buffer)) + info.ring_buffer_size);
			}
			else
			{
				info.horizontal_buffer = (float*) (((byte*) (info.decode_buffer)) + info.decode_buffer_size);
				info.ring_buffer = (float*) (((byte*) (info.horizontal_buffer)) + info.horizontal_buffer_size);
				info.encode_buffer = null;
			}

			info.ring_buffer_begin_index = (int) (-1);
			stbir__calculate_filters(info, info.horizontal_contributors, info.horizontal_coefficients,
				(int) (info.horizontal_filter), (float) (info.horizontal_scale), (float) (info.horizontal_shift),
				(int) (info.input_w), (int) (info.output_w));
			stbir__calculate_filters(info, info.vertical_contributors, info.vertical_coefficients, (int) (info.vertical_filter),
				(float) (info.vertical_scale), (float) (info.vertical_shift), (int) (info.input_h), (int) (info.output_h));
			if ((stbir__use_height_upsampling(info)) != 0) stbir__buffer_loop_upsample(info);
			else stbir__buffer_loop_downsample(info);
			return (int) (1);
		}

		public static int stbir__resize_arbitrary(void* alloc_context, void* input_data, int input_w, int input_h,
			int input_stride_in_bytes, void* output_data, int output_w, int output_h, int output_stride_in_bytes, float s0,
			float t0, float s1, float t1, float* transform, int channels, int alpha_channel, uint flags, int type, int h_filter,
			int v_filter, int edge_horizontal, int edge_vertical, int colorspace)
		{
			stbir__info info = new stbir__info();
			int result;
			ulong memory_required;
			void* extra_memory;
			stbir__setup(info, (int) (input_w), (int) (input_h), (int) (output_w), (int) (output_h), (int) (channels));
			stbir__calculate_transform(info, (float) (s0), (float) (t0), (float) (s1), (float) (t1), transform);
			stbir__choose_filter(info, (int) (h_filter), (int) (v_filter));
			memory_required = (ulong) (stbir__calculate_memory(info));
			extra_memory = malloc((ulong) (memory_required));
			if (extra_memory == null) return (int) (0);
			result =
				(int)
					(stbir__resize_allocated(info, input_data, (int) (input_stride_in_bytes), output_data,
						(int) (output_stride_in_bytes), (int) (alpha_channel), (uint) (flags), (int) (type), (int) (edge_horizontal),
						(int) (edge_vertical), (int) (colorspace), extra_memory, (ulong) (memory_required)));
			free(extra_memory);
			return (int) (result);
		}

		public static int stbir_resize_uint8(byte* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			byte* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int num_channels)
		{
			return
				(int)
					(stbir__resize_arbitrary(null, input_pixels, (int) (input_w), (int) (input_h), (int) (input_stride_in_bytes),
						output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes), (float) (0), (float) (0),
						(float) (1), (float) (1), null, (int) (num_channels), (int) (-1), (uint) (0), (int) (STBIR_TYPE_UINT8),
						(int) (STBIR_FILTER_DEFAULT), (int) (STBIR_FILTER_DEFAULT), (int) (STBIR_EDGE_CLAMP), (int) (STBIR_EDGE_CLAMP),
						(int) (STBIR_COLORSPACE_LINEAR)));
		}

		public static int stbir_resize_float(float* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			float* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int num_channels)
		{
			return
				(int)
					(stbir__resize_arbitrary(null, input_pixels, (int) (input_w), (int) (input_h), (int) (input_stride_in_bytes),
						output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes), (float) (0), (float) (0),
						(float) (1), (float) (1), null, (int) (num_channels), (int) (-1), (uint) (0), (int) (STBIR_TYPE_FLOAT),
						(int) (STBIR_FILTER_DEFAULT), (int) (STBIR_FILTER_DEFAULT), (int) (STBIR_EDGE_CLAMP), (int) (STBIR_EDGE_CLAMP),
						(int) (STBIR_COLORSPACE_LINEAR)));
		}

		public static int stbir_resize_uint8_srgb(byte* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			byte* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int num_channels, int alpha_channel,
			int flags)
		{
			return
				(int)
					(stbir__resize_arbitrary(null, input_pixels, (int) (input_w), (int) (input_h), (int) (input_stride_in_bytes),
						output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes), (float) (0), (float) (0),
						(float) (1), (float) (1), null, (int) (num_channels), (int) (alpha_channel), (uint) (flags),
						(int) (STBIR_TYPE_UINT8),
						(int) (STBIR_FILTER_DEFAULT), (int) (STBIR_FILTER_DEFAULT), (int) (STBIR_EDGE_CLAMP), (int) (STBIR_EDGE_CLAMP),
						(int) (STBIR_COLORSPACE_SRGB)));
		}

		public static int stbir_resize_uint8_srgb_edgemode(byte* input_pixels, int input_w, int input_h,
			int input_stride_in_bytes, byte* output_pixels, int output_w, int output_h, int output_stride_in_bytes,
			int num_channels, int alpha_channel, int flags, int edge_wrap_mode)
		{
			return
				(int)
					(stbir__resize_arbitrary(null, input_pixels, (int) (input_w), (int) (input_h), (int) (input_stride_in_bytes),
						output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes), (float) (0), (float) (0),
						(float) (1), (float) (1), null, (int) (num_channels), (int) (alpha_channel), (uint) (flags),
						(int) (STBIR_TYPE_UINT8),
						(int) (STBIR_FILTER_DEFAULT), (int) (STBIR_FILTER_DEFAULT), (int) (edge_wrap_mode), (int) (edge_wrap_mode),
						(int) (STBIR_COLORSPACE_SRGB)));
		}

		public static int stbir_resize_uint8_generic(byte* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			byte* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int num_channels, int alpha_channel,
			int flags, int edge_wrap_mode, int filter, int space, void* alloc_context)
		{
			return
				(int)
					(stbir__resize_arbitrary(alloc_context, input_pixels, (int) (input_w), (int) (input_h),
						(int) (input_stride_in_bytes), output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes),
						(float) (0), (float) (0), (float) (1), (float) (1), null, (int) (num_channels), (int) (alpha_channel),
						(uint) (flags),
						(int) (STBIR_TYPE_UINT8), (int) (filter), (int) (filter), (int) (edge_wrap_mode), (int) (edge_wrap_mode),
						(int) (space)));
		}

		public static int stbir_resize_uint16_generic(ushort* input_pixels, int input_w, int input_h,
			int input_stride_in_bytes, ushort* output_pixels, int output_w, int output_h, int output_stride_in_bytes,
			int num_channels, int alpha_channel, int flags, int edge_wrap_mode, int filter, int space, void* alloc_context)
		{
			return
				(int)
					(stbir__resize_arbitrary(alloc_context, input_pixels, (int) (input_w), (int) (input_h),
						(int) (input_stride_in_bytes), output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes),
						(float) (0), (float) (0), (float) (1), (float) (1), null, (int) (num_channels), (int) (alpha_channel),
						(uint) (flags),
						(int) (STBIR_TYPE_UINT16), (int) (filter), (int) (filter), (int) (edge_wrap_mode), (int) (edge_wrap_mode),
						(int) (space)));
		}

		public static int stbir_resize_float_generic(float* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			float* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int num_channels, int alpha_channel,
			int flags, int edge_wrap_mode, int filter, int space, void* alloc_context)
		{
			return
				(int)
					(stbir__resize_arbitrary(alloc_context, input_pixels, (int) (input_w), (int) (input_h),
						(int) (input_stride_in_bytes), output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes),
						(float) (0), (float) (0), (float) (1), (float) (1), null, (int) (num_channels), (int) (alpha_channel),
						(uint) (flags),
						(int) (STBIR_TYPE_FLOAT), (int) (filter), (int) (filter), (int) (edge_wrap_mode), (int) (edge_wrap_mode),
						(int) (space)));
		}

		public static int stbir_resize(void* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			void* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int datatype, int num_channels,
			int alpha_channel, int flags, int edge_mode_horizontal, int edge_mode_vertical, int filter_horizontal,
			int filter_vertical, int space, void* alloc_context)
		{
			return
				(int)
					(stbir__resize_arbitrary(alloc_context, input_pixels, (int) (input_w), (int) (input_h),
						(int) (input_stride_in_bytes), output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes),
						(float) (0), (float) (0), (float) (1), (float) (1), null, (int) (num_channels), (int) (alpha_channel),
						(uint) (flags),
						(int) (datatype), (int) (filter_horizontal), (int) (filter_vertical), (int) (edge_mode_horizontal),
						(int) (edge_mode_vertical), (int) (space)));
		}

		public static int stbir_resize_subpixel(void* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			void* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int datatype, int num_channels,
			int alpha_channel, int flags, int edge_mode_horizontal, int edge_mode_vertical, int filter_horizontal,
			int filter_vertical, int space, void* alloc_context, float x_scale, float y_scale, float x_offset, float y_offset)
		{
			float* transform = stackalloc float[4];
			transform[0] = (float) (x_scale);
			transform[1] = (float) (y_scale);
			transform[2] = (float) (x_offset);
			transform[3] = (float) (y_offset);
			return
				(int)
					(stbir__resize_arbitrary(alloc_context, input_pixels, (int) (input_w), (int) (input_h),
						(int) (input_stride_in_bytes), output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes),
						(float) (0), (float) (0), (float) (1), (float) (1), transform, (int) (num_channels), (int) (alpha_channel),
						(uint) (flags), (int) (datatype), (int) (filter_horizontal), (int) (filter_vertical), (int) (edge_mode_horizontal),
						(int) (edge_mode_vertical), (int) (space)));
		}

		public static int stbir_resize_region(void* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			void* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int datatype, int num_channels,
			int alpha_channel, int flags, int edge_mode_horizontal, int edge_mode_vertical, int filter_horizontal,
			int filter_vertical, int space, void* alloc_context, float s0, float t0, float s1, float t1)
		{
			return
				(int)
					(stbir__resize_arbitrary(alloc_context, input_pixels, (int) (input_w), (int) (input_h),
						(int) (input_stride_in_bytes), output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes),
						(float) (s0), (float) (t0), (float) (s1), (float) (t1), null, (int) (num_channels), (int) (alpha_channel),
						(uint) (flags), (int) (datatype), (int) (filter_horizontal), (int) (filter_vertical), (int) (edge_mode_horizontal),
						(int) (edge_mode_vertical), (int) (space)));
		}
	}
}